JAVA 9 (21 сентября 2017 )

##1) Появление литералов в коллекциях

В 9 версии вы можете использовать нечто подобное без каких-либо предварительных подготовок:
```
List<Integer> piDigits = List.of(3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 9);
Set<Integer> primes = Set.of(2, 7, 31, 127, 8191, 131071, 524287);
```

##2) Внедрение оператора Элвиса

Этот оператор реализован на Groovy на синтаксическом уровне, но если вы попробуете написать на джаве нечто подобное
        Robot robot = t1000 ?: defaultRobot;

компилятор предсказуемо ругнется. В девятке внедрили подобную логику, правда не на уровне синтаксиса. Ниже приведены два эквивалентных выражения на девятке и в уже привычном виде.
```
Robot robot = Objects.requireNonNullElse(t1000, defaultRobot) //It will be work on Java 9
Optional<Robot> robot = t1000; // Familiar resolution
robot = robot.orElse(defaultRobot);
```
##3) Class Optional

Метод or интуитивно понятен: будет возвращен вызывающий объект, если он не нулевой, в противном случае вернется аргумент.
``` 
robot = robot.or(() ->t1000); // Another Optional
```
Следующий метод выполняет заданное действие над значением, если оно присутствует, в противном случае будет выполнено некое дефолтное действие.
```
Optional.ofNullable(message)
                .ifPresentOrElse(System.out::println, () -> System.out.println("I am a CircleHead")); // Runnable
```
##4)Модульность в Java 9 
Основным нововведением Java 9 было именно введение модульности. 
Какие цели ставили перед собой разработчики:
####• облегчить разработку больших приложений и библиотек;
####• улучшить безопасность Java SE в целом, и JDK в частности;
####• увеличить производительность приложений;
####• создать возможность уменьшения размера JRE для запуска на небольших девайсах, чтобы не потреблять слишком много памяти;

До 9 версии, JDK и JRE были монолитными. Их размер рос с каждым релизом. Java 8 занимала уже сотни мегабайт, и все это разработчикам приходилось “таскать с собой” каждый раз, чтобы иметь возможность запускать Java приложения. 
В JDK 9 было введено разделение на модули, а именно, JDK была разделена на 73 модуля. И с каждой новой версией количество этих модулей растет. В 11 версии это число близится к 100. Это разделение позволило разработчикам создать утилиту JLINK. С помощью JLINK можно создавать кастомные наборы JRE, которые будут включают только «нужные» модули, которые реально необходимы вашему приложению. 

С приходом Java 9 поменялась структура JDK: теперь она идентична структуре JRE. Если раньше JDK включала папку JRE, где снова имеется bin и дублируются файлы, то теперь все выглядит следующим образом: 

Модуль — это новый уровень агрегации пакетов и ресурсов 
 Модули поставляются в JAR файлах с пакетами и дескриптором модуля
module-info.java. Файл module-info.java содержит описание модуля:
имя, зависимости, экспортируемые пакеты, потребляемые и предоставляемые сервисы, разрешения для reflection доступа.

Примеры описания дескриптора модуля:
```
      module java.sql {
           requires transitive java.logging;
           requires transitive java.transaction.xa;
           requires transitive java.xml;
       
           exports java.sql;
           exports javax.sql;
       
           uses java.sql.Driver;
      }
```